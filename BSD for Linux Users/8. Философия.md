**Основная часть**

Ах, теперь та часть, которая мне нравится. Много обобщений без  фактов. И отсутствие каких-либо исследований. Я собираюсь обсудить здесь реальные и воображаемые философские различия, которые как и вызывают, так и вызваны некоторыми из технических и организационных различий, которые мы обсуждали ранее. Поймите, я должен подчеркнуть, что многое из обсуждаемого является очень общим. Обе системы часто не "следуют правилам" или не соответствуют их собственным ожиданиям. Это скорее вопрос склонности к исключительной реализации. Я просто говорю это сейчас, поэтому мне не нужно продолжать квалифицировать и переквалифицировать каждое высказывание, которое я делаю.

**Хаос против Порядка**
Методология Linux - это живое воплощение хаоса, тогда как методология BSD гораздо больше относится к контролю и порядку. В значительной степени это правда. Линукс вырос из опыта программирования в свободное время, а BSD вырос из контролируемого инженерного образования. Конечно, как и BSD-код может быть написан энтузиастами в выходные, так и много профессиональных программистов, занятых полный рабочий день, могут разрабатывать Linux. Но все равно ощущается раскол между этими системами.

Мы уже обсуждали методологию строительства; BSD создает единую базовую систему, в то время как дистрибутивы Linux собирают уже существующие части и в значительной степени собирают их вместе helter-skelter. Естественно, метод BSD гораздо более податлив, чтобы упорядочивать вещи, в то время как метод Linux практически требует полного хаоса. Это не значит, что хаос изначально плох, или порядок по сути хорош. Они просто разные среды.

Linux, как правило, будет гораздо более тесно преследовать новые версии других программ, принимая особенно более серьезные изменения, такие как Apache 2, гораздо раньше, чем BSD пойдет по этому пути. Теперь более строгое разделение «базовых» и «портов» в BSD, а также структура самого дерева портов упрощают использование нескольких параллельных версий пакетов в BSD. Иногда даже возможно установить несколько версий одновременно. В Linux, не имея такого разделения, очень трудно иметь параллельные версии, и вместо этого почти требуется одна «благословенная».

А примат компиляции исходного кода в пакетах также облегчает работу с несколькими версиями. Например, PHP должен быть скомпилирован по-разному, в зависимости от того, используете ли вы Apache 1.3 или Apache 2. С помощью пакетов из исходного кода, таких как порты, я могу определить переменную окружения при компиляции и установке PHP, чтобы указать, использовать ли Apache 1.3 или Apache 2. С бинарными пакетами у вас должно быть 2 отдельных пакета, что рано или поздно приведет к путанице.

**Право против Неверно**
Разницу можно также увидеть в способе интеграции кода ядра. BSD всегда уклоняется от хакерских решений, когда есть даже намеки на правильное решение. Теория состоит в том, что намного проще дождаться чистого ответа, чем интегрировать грязный ответ по нескольким причинам. С одной стороны, если вы интегрируете грязный ответ, это уменьшает стимул для реализации лучшего. С другой стороны, если вы испачкаете архитектуру для интеграции чего-либо, она никогда не будет очищена снова. Вы знаете это так же хорошо, как и я. О, конечно, вы скажете, что это временно. Но вы знаете, что нет ничего более постоянного, чем временная остановка. И вещи растут. Единственный способ избежать мили - это отказаться от первого дюйма. Это как налоги; когда в последний раз вы видели временный налог, который когда-либо уходил?

Вы также видите это в том, что там. Традиционно (хотя и не всегда), Linux интегрирует поддержку части аппаратного обеспечения раньше, чем BSD. Но когда BSD интегрирует это, это работает. Это твердое тело Это стабильно. Драйверы Linux, как правило, имеют гораздо больше различий, потому что они будут введены раньше. Во многих отношениях это отражает приведенный выше случай надстройки, но в обратном порядке. BSD имеет очень жестко контролируемую базовую систему и может быть очень свободна при настройке дополнительного программного обеспечения, поскольку все это добавляется пользователем самостоятельно. У Linux очень слабая и плавная связь между ядром и пользовательским пространством, но пользовательское пространство в целом, из-за отсутствия разделения базы / аддона, требует гораздо больше работы для поддержания согласованности, что предъявляет гораздо более высокие требования к центральному «Благо» различных версий пакетов. Широкое использование бинарного, а не исходного дистрибутива только делает это гораздо более значительным.

**Аудитория**

Ну, мы уже довольно хорошо покрыли аудиторию. Linux, с его хаотичным фоном мастеринга, естественно, в целом привлекает другую личность, чем BSD с его академическим и строгим опытом. Лично я думаю, что это сдерживает Linux в некоторых отношениях, которые становятся все более очевидными в последнее время. Случайный хаос, безусловно, имеет свои преимущества, но не без недостатков.

**Последствия дизайна**

Методика поэтапной сборки в Linux позволяет (теоретически) просто обновить один компонент. В BSD легко обновить отдельные части, которые являются «надстройкой» от портов, но части, которые интегрированы в базовую систему, не могут быть легко перепутаны независимо.

Например, OpenSSL импортируется и поддерживается в базовой системе, но я не могу просто обновить его самостоятельно; Я должен обновить всю базовую систему. И это включает в себя ядро, а также ls и gzip и gcc и less, а также ssh, sendmail и BIND. (Конечно, вы всегда можете установить разные версии sendmail и BIND, или Postfix и djbdns через порты, и просто запустить другую версию вместо базовой; она просто будет сидеть, занимая место на диске, что дешево).

В теории это проблема. На практике я обнаружил, что обычно все равно легче. Я не могу сосчитать, сколько раз я блокировал себя из удаленного Linux-бокса, обновляя OpenSSL, затем пытаясь обновить или перезапустить ssh, и у него не получилось, потому что он ищет другую версию OpenSSL. С интегрированной системой это не проблема, поскольку они будут автоматически синхронизированы. А с их сборкой из исходного кода они все равно будут автоматически синхронизированы, даже если они не были интегрированы вместе в базовую систему.

В результате этой и подобных ситуаций не так-то просто поддерживать системы Linux в «современном состоянии». Отдельные выпуски данного дистрибутива гораздо более независимы друг от друга, поэтому сложнее превратить вашу систему RedHat 7.3 в систему RedHat 8. Новые пакеты для 7.3 создаются и обновляются в течение определенного периода времени, и часто действительно новые версии пакетов никогда не поступают. И если вы пытаетесь использовать пакеты из другой версии вашего дистрибутива или из другого дистрибутива, вы часто столкнуться с отсутствующими зависимостями и проблемами с различными версиями других программ. И как бы трудно ни было поддерживать систему в актуальном состоянии, еще сложнее привести их в актуальное состояние после периода отсутствия заботы.

С другой стороны, у меня есть BSD-системы, которые я установил в 1997 году, и они всегда были (и остаются на сегодняшний день) с последним ядром, последней версией Apache, последней Mozilla и самой последней версией всего. Однако в системе Linux вы, как правило, пытаетесь обновлять несколько очевидных вещей, тогда как другие отстают все дальше и дальше, пока в конечном итоге вы просто не переустановите последнюю версию, чтобы обновить ее. Эти методологии привлекают довольно разных администраторов.

**Мифы**

Мы потратили много времени на обсуждение различий между BSD и Linux. Мы потратили много времени на разговоры о том, как работает BSD. И теперь мы как бы раскрыли, что такое BSD. Итак, давайте кратко рассмотрим, чем не является BSD, и развеем некоторые мифы.
